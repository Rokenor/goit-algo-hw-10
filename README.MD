# Task01

### Порівняння жадібного алгоритму та динамічного програмування

**Порівняння продуктивності**

| Сума | Жадібний (час, сек) | Динамічний(час, сек) |
|:---- |:---- |:---- |
| 113 | 0.00003460 | 0.00249200 |
| 987 | 0.00002440 | 0.02317180 |
| 8654 | 0.00002000 | 0.20987600 |
| 32768 | 0.00002850 | 0.86470640 |
| 100000 | 0.00001950  | 2.76202530 |
| 2300000 | 0.00001730 | 65.11614870 |

**Аналіз результатів:**

* Час роботи **жадібного алгоритму** залишається практично незмінним і близьким до нуля, що підтверджує його часову складність **O(k)** але не завжди знаходить оптимальне рішення
* Час роботи **алгоритму динамічного програмування** помітно зростає зі збільшенням суми, що ілюструє його залежність від вхідних даних (**O(amount * k)**) але завжди гарантує оптимальне рішення

**Висновок**

Для задачі касового апарату зі стандартним набором монет **жадібний алгоритм є найкращим вибором**. Він значно швидший, простіший у реалізації та менш вимогливий до ресурсів, при цьому надаючи коректний результат.

Алгоритм динамічного програмування є більш потужним та універсальним інструментом, який варто застосовувати у випадках, коли набір номіналів не є канонічним і жадібний підхід може призвести до неоптимального рішення.

# Task02

### Аналіз точності методу Монте-Карло для обчислення інтеграла

**Результати обчислень**

| Метод обчислення | Отримане значення інтеграла |
|:---- |:---- |
| Метод Монте-Карло | 2.66104 (при кожному запуску значення незначно змінюється) |
| scipy.integrate.quad | 2.666666666666667 |

**Аналіз результатів:**

* Функція *scipy.integrate.quad* дає точний результат. Це значення є еталонним для порівняння
* Метод Монте-Карло дає дуже близьке, але не абсолютно точне значення. Його результат є наближенням. Результат залежить від випадковості і буде трохи відрізнятися при кожному новому запуску програми

**Висновок**

Метод Монте-Карло успішно впорався із завданням знаходження площі під кривою, продемонструвавши результат, дуже близький до точного аналітичного значення.